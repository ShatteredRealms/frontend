// @generated by protobuf-ts 2.9.4 with parameter long_type_number
// @generated from protobuf file "sro/gameserver/connection.proto" (package "sro.gameserver", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ConnectionService } from "./connection";
import type { ConnectionStatus } from "./connection";
import type { TransferPlayerRequest } from "./connection";
import type { VerifyConnectRequest } from "./connection";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ConnectGameServerResponse } from "./connection";
import type { TargetId } from "../globals";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service sro.gameserver.ConnectionService
 */
export interface IConnectionServiceClient {
    /**
     * @generated from protobuf rpc: ConnectGameServer(sro.TargetId) returns (sro.gameserver.ConnectGameServerResponse);
     */
    connectGameServer(input: TargetId, options?: RpcOptions): UnaryCall<TargetId, ConnectGameServerResponse>;
    /**
     * Called by the gameserver to verifying and incoming connection
     * request. Returns the character id if the connection was successful
     *
     * @generated from protobuf rpc: VerifyConnect(sro.gameserver.VerifyConnectRequest) returns (sro.TargetId);
     */
    verifyConnect(input: VerifyConnectRequest, options?: RpcOptions): UnaryCall<VerifyConnectRequest, TargetId>;
    /**
     * @generated from protobuf rpc: TransferPlayer(sro.gameserver.TransferPlayerRequest) returns (sro.gameserver.ConnectGameServerResponse);
     */
    transferPlayer(input: TransferPlayerRequest, options?: RpcOptions): UnaryCall<TransferPlayerRequest, ConnectGameServerResponse>;
    /**
     * @generated from protobuf rpc: IsCharacterPlaying(sro.TargetId) returns (sro.gameserver.ConnectionStatus);
     */
    isCharacterPlaying(input: TargetId, options?: RpcOptions): UnaryCall<TargetId, ConnectionStatus>;
    /**
     * @generated from protobuf rpc: IsUserPlaying(sro.TargetId) returns (sro.gameserver.ConnectionStatus);
     */
    isUserPlaying(input: TargetId, options?: RpcOptions): UnaryCall<TargetId, ConnectionStatus>;
}
/**
 * @generated from protobuf service sro.gameserver.ConnectionService
 */
export class ConnectionServiceClient implements IConnectionServiceClient, ServiceInfo {
    typeName = ConnectionService.typeName;
    methods = ConnectionService.methods;
    options = ConnectionService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: ConnectGameServer(sro.TargetId) returns (sro.gameserver.ConnectGameServerResponse);
     */
    connectGameServer(input: TargetId, options?: RpcOptions): UnaryCall<TargetId, ConnectGameServerResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<TargetId, ConnectGameServerResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Called by the gameserver to verifying and incoming connection
     * request. Returns the character id if the connection was successful
     *
     * @generated from protobuf rpc: VerifyConnect(sro.gameserver.VerifyConnectRequest) returns (sro.TargetId);
     */
    verifyConnect(input: VerifyConnectRequest, options?: RpcOptions): UnaryCall<VerifyConnectRequest, TargetId> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<VerifyConnectRequest, TargetId>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: TransferPlayer(sro.gameserver.TransferPlayerRequest) returns (sro.gameserver.ConnectGameServerResponse);
     */
    transferPlayer(input: TransferPlayerRequest, options?: RpcOptions): UnaryCall<TransferPlayerRequest, ConnectGameServerResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransferPlayerRequest, ConnectGameServerResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: IsCharacterPlaying(sro.TargetId) returns (sro.gameserver.ConnectionStatus);
     */
    isCharacterPlaying(input: TargetId, options?: RpcOptions): UnaryCall<TargetId, ConnectionStatus> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<TargetId, ConnectionStatus>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: IsUserPlaying(sro.TargetId) returns (sro.gameserver.ConnectionStatus);
     */
    isUserPlaying(input: TargetId, options?: RpcOptions): UnaryCall<TargetId, ConnectionStatus> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<TargetId, ConnectionStatus>("unary", this._transport, method, opt, input);
    }
}
